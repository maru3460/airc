# GitHub トークン認証機能 - 設計

## アーキテクチャ概要

### 設計思想

1. **後方互換性**: Token がなくても既存の動作を維持
2. **シンプルさ**: 環境変数のみで動作、複雑な設定不要
3. **安全性**: Token をログやエラーメッセージに含めない
4. **将来の拡張性**: multi-source 機能への移行を見据えた設計

### アーキテクチャ図

```
┌─────────────────────────────────────────────────┐
│              CLI Interface (cli.ts)              │
│  - コマンドライン引数解析                         │
│  - 環境変数読み込み (GITHUB_TOKEN)               │
└──────────────────┬──────────────────────────────┘
                   │
         ┌─────────▼──────────┐
         │  GitHub API Client │
         │  (github/api.ts)   │
         │                    │
         │ - fetchWithAuth()  │
         │ - checkRateLimit() │
         └─────────┬──────────┘
                   │
       ┌───────────┼───────────┐
       │           │           │
┌──────▼─────┐ ┌──▼──────┐ ┌──▼────────┐
│  未認証    │ │  認証済  │ │ レート制限│
│  リクエスト│ │リクエスト│ │  監視     │
│            │ │         │ │           │
│ 60/時間   │ │5000/時間│ │ 警告表示  │
└────────────┘ └─────────┘ └───────────┘
```

## ファイル構成

### 変更するファイル

```
src/
├── cli.ts                      # 環境変数読み込み処理を追加
├── types.ts                    # 認証関連の型定義を追加
├── github/
│   ├── api.ts                  # 認証付き API 呼び出し機能を追加
│   └── download.ts             # 認証オプションを追加
└── utils/
    └── logger.ts               # レート制限警告用ロガー（新規）
```

## データ構造

### 型定義 (`src/types.ts`)

```typescript
/**
 * GitHub API 呼び出しオプション
 */
export interface GitHubAPIOptions {
  /**
   * GitHub Personal Access Token（オプショナル）
   */
  token?: string;
}

/**
 * GitHub API レート制限情報
 */
export interface RateLimitInfo {
  /**
   * レート制限の最大値
   */
  limit: number;

  /**
   * 残りリクエスト数
   */
  remaining: number;

  /**
   * リセット時刻（Unix timestamp）
   */
  reset: number;

  /**
   * 認証済みかどうか
   */
  authenticated: boolean;
}

/**
 * ダウンロード処理の結果
 */
export interface DownloadResult {
  /**
   * ダウンロードしたファイル数
   */
  filesDownloaded: number;

  /**
   * スキップしたファイル数
   */
  filesSkipped: number;

  /**
   * エラーが発生したファイル数
   */
  filesErrored: number;

  /**
   * レート制限情報（取得できた場合）
   */
  rateLimit?: RateLimitInfo;
}
```

## 主要な実装詳細

### 1. 環境変数の読み込み (`src/cli.ts`)

```typescript
/**
 * 環境変数から GitHub Token を取得
 */
function getGitHubToken(): string | undefined {
  const token = process.env.GITHUB_TOKEN;

  if (token) {
    // Token の形式を簡易チェック（ghp_ で始まるか）
    if (!token.startsWith('ghp_') && !token.startsWith('github_pat_')) {
      console.warn('⚠️  GITHUB_TOKEN の形式が不正です');
      return undefined;
    }
  }

  return token;
}
```

### 2. 認証付き GitHub API 呼び出し (`src/github/api.ts`)

```typescript
import type { GitHubAPIOptions, RateLimitInfo } from '../types';

/**
 * GitHub API を呼び出す（認証対応）
 */
export async function fetchWithAuth(
  url: string,
  options?: GitHubAPIOptions
): Promise<Response> {
  const headers: HeadersInit = {
    'Accept': 'application/vnd.github.v3+json',
    'User-Agent': 'airc-cli',
  };

  // Token が設定されている場合は認証ヘッダーを追加
  if (options?.token) {
    headers['Authorization'] = `Bearer ${options.token}`;
  }

  const response = await fetch(url, {
    headers,
    // タイムアウト設定（10秒）
    signal: AbortSignal.timeout(10000),
  });

  return response;
}

/**
 * レート制限情報を取得
 */
export function getRateLimitInfo(response: Response): RateLimitInfo | null {
  const limit = response.headers.get('X-RateLimit-Limit');
  const remaining = response.headers.get('X-RateLimit-Remaining');
  const reset = response.headers.get('X-RateLimit-Reset');

  if (!limit || !remaining || !reset) {
    return null;
  }

  return {
    limit: parseInt(limit, 10),
    remaining: parseInt(remaining, 10),
    reset: parseInt(reset, 10),
    authenticated: parseInt(limit, 10) > 60,
  };
}

/**
 * レート制限の警告を表示
 */
export function checkRateLimitWarning(rateLimit: RateLimitInfo): void {
  const { remaining, limit, reset, authenticated } = rateLimit;

  // 残りが10%未満になったら警告
  const threshold = Math.floor(limit * 0.1);

  if (remaining < threshold) {
    const resetDate = new Date(reset * 1000);
    const authStatus = authenticated ? '認証済み' : '未認証';

    console.warn(
      `⚠️  GitHub API レート制限: 残り ${remaining}/${limit} リクエスト (${authStatus})`
    );
    console.warn(`   リセット時刻: ${resetDate.toLocaleString('ja-JP')}`);

    if (!authenticated) {
      console.warn(
        '   💡 GITHUB_TOKEN 環境変数を設定すると、5,000リクエスト/時間まで使用できます'
      );
    }
  }
}

/**
 * ファイルリストを取得（再帰的、認証対応）
 */
export async function listFilesRecursive(
  owner: string,
  repo: string,
  path: string,
  branch: string = 'main',
  options?: GitHubAPIOptions
): Promise<GitHubFileInfo[]> {
  const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path}?ref=${branch}`;
  const response = await fetchWithAuth(url, options);

  // レート制限をチェック
  const rateLimit = getRateLimitInfo(response);
  if (rateLimit) {
    checkRateLimitWarning(rateLimit);
  }

  if (!response.ok) {
    if (response.status === 403) {
      const rateLimit = getRateLimitInfo(response);
      if (rateLimit && rateLimit.remaining === 0) {
        throw new Error(
          `GitHub API レート制限に到達しました。リセット時刻: ${new Date(
            rateLimit.reset * 1000
          ).toLocaleString('ja-JP')}`
        );
      }
    }

    throw new Error(
      `GitHub API エラー: ${response.status} ${response.statusText}`
    );
  }

  const data = await response.json();

  if (!Array.isArray(data)) {
    return [];
  }

  const files: GitHubFileInfo[] = [];

  for (const item of data) {
    if (item.type === 'file') {
      files.push({
        path: item.path,
        type: 'file',
        download_url: item.download_url,
      });
    } else if (item.type === 'dir') {
      // 再帰的にディレクトリを探索
      const subFiles = await listFilesRecursive(
        owner,
        repo,
        item.path,
        branch,
        options
      );
      files.push(...subFiles);
    }
  }

  return files;
}
```

### 3. ダウンロード処理の更新 (`src/github/download.ts`)

```typescript
import type { GitHubAPIOptions, DownloadResult, RateLimitInfo } from '../types';
import { fetchWithAuth, getRateLimitInfo } from './api';

/**
 * ファイルをダウンロード（認証対応）
 */
export async function downloadFile(
  downloadUrl: string,
  localPath: string,
  options?: GitHubAPIOptions
): Promise<void> {
  const response = await fetchWithAuth(downloadUrl, options);

  if (!response.ok) {
    throw new Error(
      `ダウンロード失敗: ${response.status} ${response.statusText}`
    );
  }

  const content = await response.text();

  // ディレクトリ作成
  const dir = path.dirname(localPath);
  await fs.mkdir(dir, { recursive: true });

  // ファイル書き込み
  await fs.writeFile(localPath, content, 'utf-8');
}

/**
 * 複数ファイルをダウンロード
 */
export async function downloadFiles(
  files: GitHubFileInfo[],
  options?: GitHubAPIOptions & { force?: boolean }
): Promise<DownloadResult> {
  const result: DownloadResult = {
    filesDownloaded: 0,
    filesSkipped: 0,
    filesErrored: 0,
  };

  let lastRateLimit: RateLimitInfo | undefined;

  for (const file of files) {
    try {
      const localPath = convertToLocalPath(file.path);

      // 既存ファイルのチェック
      const exists = await fs
        .access(localPath)
        .then(() => true)
        .catch(() => false);

      if (exists && !options?.force) {
        // 上書き確認
        const shouldOverwrite = await confirmOverwrite(localPath);
        if (!shouldOverwrite) {
          result.filesSkipped++;
          continue;
        }
      }

      // ダウンロード実行
      await downloadFile(file.download_url, localPath, options);
      result.filesDownloaded++;

      console.log(`✅ ${localPath}`);
    } catch (error) {
      result.filesErrored++;
      console.error(`❌ ${file.path}: ${error.message}`);
    }
  }

  result.rateLimit = lastRateLimit;

  return result;
}
```

### 4. ロガーユーティリティ (`src/utils/logger.ts`)

```typescript
/**
 * レート制限情報を表示
 */
export function logRateLimitSummary(rateLimit: RateLimitInfo): void {
  const { remaining, limit, authenticated } = rateLimit;
  const percentage = Math.floor((remaining / limit) * 100);

  console.log('\n📊 GitHub API レート制限情報:');
  console.log(`   残り: ${remaining}/${limit} リクエスト (${percentage}%)`);
  console.log(`   状態: ${authenticated ? '✅ 認証済み' : '⚠️  未認証'}`);

  if (!authenticated) {
    console.log(
      '\n💡 ヒント: GITHUB_TOKEN 環境変数を設定すると、5,000リクエスト/時間まで使用できます'
    );
  }
}
```

## エラーハンドリング

### 1. レート制限エラー

```typescript
if (response.status === 403) {
  const rateLimit = getRateLimitInfo(response);

  if (rateLimit && rateLimit.remaining === 0) {
    const resetDate = new Date(rateLimit.reset * 1000);
    throw new Error(
      `GitHub API レート制限に到達しました。\n` +
        `リセット時刻: ${resetDate.toLocaleString('ja-JP')}\n` +
        `現在の制限: ${rateLimit.limit}リクエスト/時間 (${
          rateLimit.authenticated ? '認証済み' : '未認証'
        })`
    );
  }
}
```

### 2. Token 形式エラー

```typescript
function validateToken(token: string): boolean {
  // Personal Access Token の形式チェック
  if (token.startsWith('ghp_') || token.startsWith('github_pat_')) {
    return true;
  }

  console.warn('⚠️  GITHUB_TOKEN の形式が不正です');
  console.warn('   正しい形式: ghp_xxxx または github_pat_xxxx');
  return false;
}
```

### 3. 認証エラー

```typescript
if (response.status === 401) {
  throw new Error(
    'GitHub API 認証エラー: GITHUB_TOKEN が無効です。\n' +
      '新しいトークンを生成してください。'
  );
}
```

## セキュリティ考慮事項

### 1. Token のログ出力防止

```typescript
/**
 * エラーメッセージから Token を除去
 */
function sanitizeErrorMessage(message: string, token?: string): string {
  if (!token) return message;

  // Token を "*****" に置換
  return message.replace(new RegExp(token, 'g'), '*****');
}
```

### 2. Token の検証

```typescript
/**
 * Token のスコープを確認（将来的な拡張）
 */
async function validateTokenScopes(token: string): Promise<string[]> {
  const response = await fetch('https://api.github.com/user', {
    headers: {
      Authorization: `Bearer ${token}`,
    },
  });

  const scopes = response.headers.get('X-OAuth-Scopes');
  return scopes ? scopes.split(', ') : [];
}
```

## パフォーマンス考慮事項

### 1. キャッシュ戦略（将来的な実装）

```typescript
interface CacheEntry {
  files: GitHubFileInfo[];
  timestamp: number;
  etag: string;
}

/**
 * ファイルリストをキャッシュ
 */
class FileListCache {
  private cache = new Map<string, CacheEntry>();
  private ttl = 5 * 60 * 1000; // 5分

  async get(key: string): Promise<GitHubFileInfo[] | null> {
    const entry = this.cache.get(key);

    if (!entry) return null;

    // TTL チェック
    if (Date.now() - entry.timestamp > this.ttl) {
      this.cache.delete(key);
      return null;
    }

    return entry.files;
  }

  set(key: string, files: GitHubFileInfo[], etag: string): void {
    this.cache.set(key, {
      files,
      timestamp: Date.now(),
      etag,
    });
  }
}
```

### 2. リトライ戦略

```typescript
/**
 * リトライ付き fetch
 */
async function fetchWithRetry(
  url: string,
  options: RequestInit,
  maxRetries = 3
): Promise<Response> {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url, options);

      // 429 (Too Many Requests) の場合はリトライ
      if (response.status === 429) {
        const retryAfter = response.headers.get('Retry-After');
        const delay = retryAfter ? parseInt(retryAfter) * 1000 : 1000 * (i + 1);

        console.warn(`⚠️  レート制限に到達。${delay}ms 後にリトライします...`);
        await new Promise(resolve => setTimeout(resolve, delay));
        continue;
      }

      return response;
    } catch (error) {
      if (i === maxRetries - 1) throw error;

      console.warn(`⚠️  リクエスト失敗。リトライ ${i + 1}/${maxRetries}...`);
      await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
    }
  }

  throw new Error('最大リトライ回数に到達しました');
}
```

## テスト戦略

### 1. ユニットテスト

```typescript
describe('GitHub API', () => {
  describe('fetchWithAuth', () => {
    it('Token なしで API を呼び出せる', async () => {
      const response = await fetchWithAuth('https://api.github.com/repos/maru3460/airc');
      expect(response.ok).toBe(true);
    });

    it('Token ありで API を呼び出せる', async () => {
      const response = await fetchWithAuth(
        'https://api.github.com/repos/maru3460/airc',
        { token: process.env.GITHUB_TOKEN }
      );
      expect(response.ok).toBe(true);
    });
  });

  describe('getRateLimitInfo', () => {
    it('レート制限情報を取得できる', () => {
      const mockResponse = new Response(null, {
        headers: {
          'X-RateLimit-Limit': '5000',
          'X-RateLimit-Remaining': '4999',
          'X-RateLimit-Reset': '1634567890',
        },
      });

      const rateLimit = getRateLimitInfo(mockResponse);

      expect(rateLimit).toEqual({
        limit: 5000,
        remaining: 4999,
        reset: 1634567890,
        authenticated: true,
      });
    });
  });
});
```

### 2. 統合テスト

```typescript
describe('認証機能の統合テスト', () => {
  it('Token なしでもファイルをダウンロードできる', async () => {
    const files = await listFilesRecursive('maru3460', 'airc', 'profiles/default');
    expect(files.length).toBeGreaterThan(0);
  });

  it('Token ありでファイルをダウンロードできる', async () => {
    const files = await listFilesRecursive(
      'maru3460',
      'airc',
      'profiles/default',
      'main',
      { token: process.env.GITHUB_TOKEN }
    );
    expect(files.length).toBeGreaterThan(0);
  });
});
```

## マイグレーション戦略

### 既存コードとの互換性

- **Token なし**: 既存の動作を維持（未認証）
- **Token あり**: 自動的に認証付きリクエストを使用

### 段階的な導入

1. **フェーズ1**: 環境変数からの Token 読み込み（この機能）
2. **フェーズ2**: レート制限の監視と警告（この機能）
3. **フェーズ3**: 設定ファイルへの対応（multi-source 機能）
4. **フェーズ4**: Private リポジトリ対応（multi-source 機能）

## 次のステップ

1. 実装コードの作成
2. ユニットテストの追加
3. ドキュメント整備（README 更新）
4. multi-source 機能への移行準備
