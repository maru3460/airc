# マルチソース対応機能 - 設計

## アーキテクチャ概要

### 設計思想

1. **ソースの抽象化**: GitHub、ローカルファイルシステムなど、異なるソースタイプを共通インターフェースで扱う
2. **設定の永続化**: ソース情報を設定ファイルに保存し、再利用可能にする
3. **後方互換性**: 既存の使い方を壊さず、新機能を追加する
4. **セキュリティ**: 認証情報を安全に管理する

### アーキテクチャ図

```
┌─────────────────────────────────────────────────┐
│              CLI Interface (cli.ts)              │
│  - コマンドライン引数解析                         │
│  - コマンドルーティング                           │
└──────────────────┬──────────────────────────────┘
                   │
         ┌─────────┴──────────┐
         │                    │
┌────────▼────────┐  ┌───────▼────────┐
│  Command Layer  │  │ Config Manager │
│  (commands/)    │  │  (config.ts)   │
│                 │  │                │
│ - add           │  │ - load/save    │
│ - sync          │  │ - validate     │
│ - list          │  │ - encrypt      │
│ - remove        │  │                │
│ - set-default   │  │                │
└────────┬────────┘  └───────┬────────┘
         │                   │
         └─────────┬─────────┘
                   │
         ┌─────────▼──────────┐
         │  Source Factory    │
         │  (sources/base.ts) │
         │                    │
         │ - createSource()   │
         └─────────┬──────────┘
                   │
       ┌───────────┼───────────┐
       │           │           │
┌──────▼─────┐ ┌──▼──────┐ ┌──▼────────┐
│  GitHub    │ │ GitHub  │ │   Local   │
│  Public    │ │ Private │ │FileSystem │
│  Source    │ │ Source  │ │  Source   │
│            │ │         │ │           │
│ (github.ts)│ │(github  │ │(local.ts) │
│            │ │ -auth.ts│ │           │
└────────────┘ └─────────┘ └───────────┘
```

## ファイル構成

### 新規ファイル

```
src/
├── cli.ts                      # CLI エントリーポイント（既存、拡張）
├── config.ts                   # 設定ファイル管理（新規）
├── commands/                   # コマンド実装（新規ディレクトリ）
│   ├── add.ts                  # ソース追加コマンド
│   ├── sync.ts                 # 同期コマンド
│   ├── list.ts                 # ソース一覧表示
│   ├── remove.ts               # ソース削除
│   └── set-default.ts          # デフォルトソース設定
├── sources/                    # ソース実装（新規ディレクトリ）
│   ├── base.ts                 # ソース基底クラス・インターフェース
│   ├── github.ts               # GitHub Public ソース（既存コードを移動）
│   ├── github-auth.ts          # GitHub Private ソース（認証あり）
│   └── local.ts                # ローカルファイルシステムソース
├── types.ts                    # 型定義（既存、拡張）
├── utils/                      # ユーティリティ（既存）
│   ├── fs.ts
│   └── path.ts
└── github/                     # GitHub API（既存）
    ├── api.ts
    └── download.ts
```

## データ構造

### 設定ファイルスキーマ

**ファイルパス**: `~/.config/airc/config.json`

```typescript
interface Config {
  /**
   * 登録済みソースのマップ
   * キー: ソース名（ユーザーが指定）
   * 値: ソース設定
   */
  sources: Record<string, SourceConfig>;

  /**
   * デフォルトソース名
   * 省略時に使用されるソース
   */
  defaultSource: string;

  /**
   * 設定ファイルバージョン（将来のマイグレーション用）
   */
  version: string;
}

type SourceConfig =
  | GitHubSourceConfig
  | LocalSourceConfig;

interface GitHubSourceConfig {
  type: 'github';

  /**
   * リポジトリ名（owner/repo 形式）
   */
  repo: string;

  /**
   * プロファイル名
   */
  profile: string;

  /**
   * ブランチ名（デフォルト: main）
   */
  branch?: string;

  /**
   * 認証方法
   */
  auth?: {
    /**
     * Token を環境変数から読み込む場合の変数名
     */
    tokenEnv?: string;

    /**
     * Token を直接保存する場合（非推奨、暗号化必須）
     */
    token?: string;
  };
}

interface LocalSourceConfig {
  type: 'local';

  /**
   * ローカルディレクトリのパス（絶対パスまたは相対パス）
   */
  path: string;
}
```

### 設定ファイルの例

```json
{
  "version": "2.0.0",
  "sources": {
    "default": {
      "type": "github",
      "repo": "maru3460/airc",
      "profile": "default",
      "branch": "main"
    },
    "company": {
      "type": "github",
      "repo": "acme-corp/ai-team-config",
      "profile": "engineering",
      "branch": "main",
      "auth": {
        "tokenEnv": "GITHUB_TOKEN"
      }
    },
    "local-dev": {
      "type": "local",
      "path": "/home/user/repos/ai-config"
    }
  },
  "defaultSource": "company"
}
```

## 主要インターフェース

### Source インターフェース

```typescript
/**
 * ソースの共通インターフェース
 * すべてのソースタイプが実装する
 */
interface Source {
  /**
   * ソースタイプ
   */
  readonly type: 'github' | 'local';

  /**
   * ソースからファイルリストを取得
   * @returns ファイル情報の配列
   */
  listFiles(): Promise<FileInfo[]>;

  /**
   * ファイルをダウンロード
   * @param file ファイル情報
   * @param localPath ローカルの保存先パス
   */
  downloadFile(file: FileInfo, localPath: string): Promise<void>;

  /**
   * ソースの接続確認
   * @returns 接続可能な場合 true
   */
  validate(): Promise<boolean>;
}

interface FileInfo {
  /**
   * ソース上のファイルパス
   */
  sourcePath: string;

  /**
   * ローカルに保存する際の相対パス
   * （profiles/{project}/ を除いたパス）
   */
  localPath: string;

  /**
   * ファイルタイプ
   */
  type: 'file' | 'dir';

  /**
   * ダウンロード URL（GitHub の場合のみ）
   */
  downloadUrl?: string;
}
```

### SourceFactory

```typescript
/**
 * ソースインスタンスを生成するファクトリ
 */
class SourceFactory {
  /**
   * ソース設定からソースインスタンスを生成
   */
  static createSource(config: SourceConfig): Source {
    switch (config.type) {
      case 'github':
        if (config.auth) {
          return new GitHubAuthSource(config);
        }
        return new GitHubPublicSource(config);

      case 'local':
        return new LocalSource(config);

      default:
        throw new Error(`Unknown source type: ${config.type}`);
    }
  }
}
```

## 実装詳細

### 1. 設定ファイル管理 (config.ts)

```typescript
import * as fs from 'fs/promises';
import * as path from 'path';
import * as os from 'os';

/**
 * 設定ファイルのデフォルトパス
 */
const DEFAULT_CONFIG_PATH = path.join(
  os.homedir(),
  '.config',
  'airc',
  'config.json'
);

export class ConfigManager {
  private configPath: string;

  constructor(configPath: string = DEFAULT_CONFIG_PATH) {
    this.configPath = configPath;
  }

  /**
   * 設定ファイルを読み込み
   */
  async load(): Promise<Config> {
    try {
      const content = await fs.readFile(this.configPath, 'utf-8');
      return JSON.parse(content);
    } catch (error) {
      // ファイルが存在しない場合はデフォルト設定を返す
      return this.createDefaultConfig();
    }
  }

  /**
   * 設定ファイルに保存
   */
  async save(config: Config): Promise<void> {
    const dir = path.dirname(this.configPath);
    await fs.mkdir(dir, { recursive: true });
    await fs.writeFile(
      this.configPath,
      JSON.stringify(config, null, 2),
      'utf-8'
    );
  }

  /**
   * デフォルト設定を生成
   */
  private createDefaultConfig(): Config {
    return {
      version: '2.0.0',
      sources: {
        default: {
          type: 'github',
          repo: 'maru3460/airc',
          profile: 'default',
          branch: 'main',
        },
      },
      defaultSource: 'default',
    };
  }

  /**
   * ソースを追加
   */
  async addSource(name: string, sourceConfig: SourceConfig): Promise<void> {
    const config = await this.load();
    config.sources[name] = sourceConfig;
    await this.save(config);
  }

  /**
   * ソースを削除
   */
  async removeSource(name: string): Promise<void> {
    const config = await this.load();
    delete config.sources[name];

    // デフォルトソースが削除された場合は 'default' に戻す
    if (config.defaultSource === name) {
      config.defaultSource = 'default';
    }

    await this.save(config);
  }

  /**
   * デフォルトソースを設定
   */
  async setDefaultSource(name: string): Promise<void> {
    const config = await this.load();

    if (!config.sources[name]) {
      throw new Error(`Source not found: ${name}`);
    }

    config.defaultSource = name;
    await this.save(config);
  }

  /**
   * ソースを取得
   */
  async getSource(name?: string): Promise<SourceConfig> {
    const config = await this.load();
    const sourceName = name || config.defaultSource;

    const sourceConfig = config.sources[sourceName];
    if (!sourceConfig) {
      throw new Error(`Source not found: ${sourceName}`);
    }

    return sourceConfig;
  }
}
```

### 2. GitHub 認証ソース (github-auth.ts)

```typescript
import { Octokit } from '@octokit/rest';

export class GitHubAuthSource implements Source {
  readonly type = 'github' as const;
  private octokit: Octokit;
  private config: GitHubSourceConfig;

  constructor(config: GitHubSourceConfig) {
    this.config = config;

    // Token を取得
    const token = this.getToken();

    // Octokit インスタンスを初期化
    this.octokit = new Octokit({
      auth: token,
    });
  }

  /**
   * Token を取得
   */
  private getToken(): string {
    if (this.config.auth?.tokenEnv) {
      // 環境変数から取得
      const token = process.env[this.config.auth.tokenEnv];
      if (!token) {
        throw new Error(
          `Environment variable not found: ${this.config.auth.tokenEnv}`
        );
      }
      return token;
    }

    if (this.config.auth?.token) {
      // 設定ファイルから取得（非推奨）
      return this.config.auth.token;
    }

    throw new Error('No authentication method configured');
  }

  async listFiles(): Promise<FileInfo[]> {
    const [owner, repo] = this.config.repo.split('/');
    const branch = this.config.branch || 'main';
    const basePath = `profiles/${this.config.profile}`;

    return this.listFilesRecursive(owner, repo, basePath, branch);
  }

  /**
   * 再帰的にファイルリストを取得
   */
  private async listFilesRecursive(
    owner: string,
    repo: string,
    path: string,
    branch: string,
    files: FileInfo[] = []
  ): Promise<FileInfo[]> {
    const response = await this.octokit.repos.getContent({
      owner,
      repo,
      path,
      ref: branch,
    });

    if (!Array.isArray(response.data)) {
      return files;
    }

    for (const item of response.data) {
      if (item.type === 'file') {
        files.push({
          sourcePath: item.path,
          localPath: this.convertToLocalPath(item.path),
          type: 'file',
          downloadUrl: item.download_url || undefined,
        });
      } else if (item.type === 'dir') {
        await this.listFilesRecursive(owner, repo, item.path, branch, files);
      }
    }

    return files;
  }

  /**
   * ソースパスをローカルパスに変換
   * profiles/{profile}/ を除去
   */
  private convertToLocalPath(sourcePath: string): string {
    const prefix = `profiles/${this.config.profile}/`;
    if (sourcePath.startsWith(prefix)) {
      return sourcePath.substring(prefix.length);
    }
    return sourcePath;
  }

  async downloadFile(file: FileInfo, localPath: string): Promise<void> {
    if (!file.downloadUrl) {
      throw new Error(`No download URL for file: ${file.sourcePath}`);
    }

    // ダウンロード処理（既存の download.ts を使用）
    const response = await fetch(file.downloadUrl);
    const content = await response.text();

    await fs.mkdir(path.dirname(localPath), { recursive: true });
    await fs.writeFile(localPath, content, 'utf-8');
  }

  async validate(): Promise<boolean> {
    try {
      const [owner, repo] = this.config.repo.split('/');
      await this.octokit.repos.get({ owner, repo });
      return true;
    } catch {
      return false;
    }
  }
}
```

### 3. ローカルソース (local.ts)

```typescript
import * as fs from 'fs/promises';
import * as path from 'path';
import { glob } from 'glob';

export class LocalSource implements Source {
  readonly type = 'local' as const;
  private config: LocalSourceConfig;

  constructor(config: LocalSourceConfig) {
    this.config = config;
  }

  async listFiles(): Promise<FileInfo[]> {
    const basePath = path.resolve(this.config.path);

    // glob でファイルを検索
    const pattern = path.join(basePath, '**/*');
    const filePaths = await glob(pattern, {
      nodir: true,
      dot: true, // . で始まるファイルも含める
    });

    return filePaths.map(filePath => ({
      sourcePath: filePath,
      localPath: path.relative(basePath, filePath),
      type: 'file' as const,
    }));
  }

  async downloadFile(file: FileInfo, localPath: string): Promise<void> {
    // ローカルファイルをコピー
    await fs.mkdir(path.dirname(localPath), { recursive: true });
    await fs.copyFile(file.sourcePath, localPath);
  }

  async validate(): Promise<boolean> {
    try {
      const stats = await fs.stat(this.config.path);
      return stats.isDirectory();
    } catch {
      return false;
    }
  }
}
```

## セキュリティ考慮事項

### 1. GitHub Token の管理

**推奨方法**: 環境変数

```json
{
  "auth": {
    "tokenEnv": "GITHUB_TOKEN"
  }
}
```

**非推奨**: 設定ファイルに直接保存

- 平文保存は絶対に避ける
- 将来的には暗号化機能を実装する予定

### 2. パス検証

ローカルソースのパス検証:

```typescript
function validatePath(inputPath: string): boolean {
  // ディレクトリトラバーサル防止
  const normalized = path.normalize(inputPath);

  // 絶対パスに変換
  const absolute = path.resolve(normalized);

  // .. が含まれていないか確認
  if (normalized.includes('..')) {
    throw new Error('Path traversal detected');
  }

  return true;
}
```

### 3. GitHub Token のスコープ

必要な最小限のスコープ:

- **Public リポジトリ**: 認証不要
- **Private リポジトリ**: `repo` スコープ（読み取り専用の場合は `repo:status`, `repo_deployment`, `public_repo`）

## マイグレーション戦略

### v1.x → v2.0 の移行

1. **初回起動時**: 既存の使い方（`airc` または `airc -p project`）を検出
2. **自動移行**: デフォルト設定ファイルを自動生成
3. **ユーザー通知**: 設定ファイルが作成されたことを通知

```typescript
async function migrateToV2(): Promise<void> {
  const configManager = new ConfigManager();

  try {
    await configManager.load();
    // 設定ファイルが存在する場合は何もしない
  } catch {
    // 設定ファイルが存在しない場合はデフォルトを作成
    const defaultConfig = {
      version: '2.0.0',
      sources: {
        default: {
          type: 'github',
          repo: 'maru3460/airc',
          profile: 'default',
          branch: 'main',
        },
      },
      defaultSource: 'default',
    };

    await configManager.save(defaultConfig);
    console.log('✨ 設定ファイルを作成しました: ~/.config/airc/config.json');
  }
}
```

## パフォーマンス考慮事項

### キャッシュ戦略

- **ファイルリストのキャッシュ**: GitHub API のレート制限対策
- **ダウンロード済みファイルのスキップ**: ハッシュ値比較で変更検出

### 並列ダウンロード

```typescript
async function downloadFiles(files: FileInfo[]): Promise<void> {
  // 最大5並列でダウンロード
  const concurrency = 5;
  const chunks = chunkArray(files, concurrency);

  for (const chunk of chunks) {
    await Promise.all(
      chunk.map(file => downloadFile(file))
    );
  }
}
```

## テスト戦略

### ユニットテスト

- `ConfigManager`: 設定の読み書き、マイグレーション
- `SourceFactory`: 各ソースタイプの生成
- `GitHubAuthSource`: GitHub API の呼び出し（モック使用）
- `LocalSource`: ローカルファイル操作

### 統合テスト

- エンドツーエンドのワークフロー
  1. ソース追加
  2. 同期実行
  3. ファイル検証

### テストデータ

- テスト用の GitHub リポジトリ
- テスト用のローカルディレクトリ
